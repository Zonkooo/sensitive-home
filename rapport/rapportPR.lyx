#LyX 1.6.2 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\floatname{algorithm}{Extrait de code}
\usepackage{pdfpages}
\end_preamble
\use_default_options false
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle headings
\bullet 1 0 9 -1
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Sensitive Home Informatique
\end_layout

\begin_layout Author

\noun on
Colombel François, Hauchecorne Eric, Vandon Raphaël
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Présentation générale du projet
\end_layout

\begin_layout Standard
Le projet Sensitive Home est divisé en deux parties : informatique et électroniq
ue.
 Ces deux parties ont été développées conjointement par deux groupes distincts.
 
\end_layout

\begin_layout Standard
L'objectif du projet est de développer une solution de domotique qui soit
 simple à mettre en place pour l'utilisateur, et sans nécessiter de travaux
 de maçonnerie.
 Cette facilité d'installation est permise par l'utilisation de multiprises
 communiquantes sur lesquelles viennent se brancher les appareils de la
 maison, et qui relaie les informations venant de capteurs sans fil situés
 dans la maison (capteur de luminosité, capteur de température, ...).
 La conception de cette multiprise constitue la partie électronique du projet.
\end_layout

\begin_layout Standard
Le comportement de la maison est ensuite régit par des profils d'utilisation
 : on distingue des profils globaux, qui s'appliquent sur la maison dans
 son ensemble, et définissent des constantes telles que la température moyenne
 à maintenir, ou la luminosité globale dans la maison ; et des profils locaux,
 qui ne s'appliquent qu'à une seule pièce, sont prioritaires sur le profil
 global, et correspondent à une activité spécifique.
 Des profils globaux type seront 
\begin_inset Quotes eld
\end_inset

jour
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nuit
\begin_inset Quotes erd
\end_inset

, ou 
\begin_inset Quotes eld
\end_inset

absence prolongée
\begin_inset Quotes erd
\end_inset

, tandis qu'un profil local pourra être 
\begin_inset Quotes eld
\end_inset

lecture dans le salon
\begin_inset Quotes erd
\end_inset

, ou 
\begin_inset Quotes eld
\end_inset

travail dans le bureau
\begin_inset Quotes erd
\end_inset

.
 Le rôle de la partie informatique du projet est de permettre la création
 et la gestion de ces profils, ce qui est réalisé à travers une interface
 Web, adaptée à n'importe quel ordinateur, mais aussi à un iPhone ou un
 iPod Touch.
 Les changements de profil sont possibles également à travers une interface
 tactile qui est mise en place facilement sur n'importe quelle surface :
 murs, portes ou tables.
\end_layout

\begin_layout Section
Architecture de la gestion de la maison
\end_layout

\begin_layout Subsection
...
\end_layout

\begin_layout Subsection
Problèmes rencontrés
\end_layout

\begin_layout Standard
collision des architectures : need UML dès le début du projet
\end_layout

\begin_layout Section
Interface Web
\end_layout

\begin_layout Standard
Afin de configurer et contrôler le reste du projet nous avons mis en place
 une interface web.
 Nous avons fait ce choix plutôt quʼune interface logicielle standard par
 soucis d'accessibilité des contrôles : une interface logicielle aurait
 permis de contrôler la maison uniquement depuis le serveur, tandis quʼavec
 une interface web il devient possible de la commander non seulement depuis
 le serveur, mais aussi depuis un autre ordinateur du réseau local, ou même
 par internet depuis le travail où un lieu de vacances.
 De plus avec lʼavènement nouveaux téléphones portables intégrant un navigateur
 internet comme notamment lʼIphone, une interface web offre la possibilité
 de transformer son téléphone en télécommande pour la maison.
 
\end_layout

\begin_layout Subsection
Technologies utilisées
\end_layout

\begin_layout Subsubsection
Côté client
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename interface.png
	lyxscale 60
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Interface"

\end_inset

Interface côté client avec clip Flash
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour que lʼinterface web soit la plus accessible possible et consultable
 sur les différents appareils et navigateurs, côté client nous avons utilisé
 du simple HTML généré et mis en page par une feuille de style en CSS.
 Pour avoir un rendu plus dynamique de lʼétat de la maison qui puisse se
 mettre à jour en temps réel sans que lʼutilisateur nʼai a envoyer de nouvelles
 requêtes manuellement, nous avons utilisé un clip en Adobe Flash (voir
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Interface"

\end_inset

) qui communique avec le serveur par lʼintermédiaire dʼun fichier XML.
 
\end_layout

\begin_layout Subsubsection
Côté serveur
\end_layout

\begin_layout Standard
Pour réaliser une interface logicielle en HTML il nous fallait utiliser
 un langage capable de le générer dynamiquement.
 Il existe trois plates-formes permettant de le faire : PHP, le framework
 .NET via lʼASP où le Java via le JSP ou les Servlets.
 Le tout le reste du projet étant en Java, que ce soit la communication
 avec la multiprise ou la gestion des profil, il apparaissait logique de
 conserver le même langage et de réaliser lʼinterface web en Java aussi.
 Il fallait donc employer Java Edition Entreprises (anciennement J2EE) car
 la version standard ne gère pas les technologies web.
 Enfin en utilisant du Java il nous restait encore deux options : le JSP,
 qui ressemble à une page HTML dans laquelle est intégré du code Java dans
 des balises, ou les Servlets, qui sont des classes Java permettant de gérer
 des requêtes HTTP et dʼécrire du HTML via la sortie standard.
 De ces deux solutions nous avons choisit dʼutiliser les Servlets car ils
 sont eux mêmes des classe Java et pouvaient à ce titre sʼintégrer plus
 facilement dans le reste du projet et communiquer directement avec les
 autres classes du projet et dʼéchanger des données avec elles.
 
\end_layout

\begin_layout Subsubsection
Serveur web
\end_layout

\begin_layout Subsection
Architecture de l'interface
\end_layout

\begin_layout Subsection
Fonctions de l'interface
\end_layout

\begin_layout Subsubsection
Menu
\end_layout

\begin_layout Subsubsection
Accueil
\end_layout

\begin_layout Subsubsection
Configuration de la maison
\end_layout

\begin_layout Subsubsection
Changement de profil
\end_layout

\begin_layout Subsubsection
Sauvegarde de la configuration
\end_layout

\begin_layout Subsubsection
Configuration d'un profil
\end_layout

\begin_layout Subsubsection
Création d'un profil
\end_layout

\begin_layout Subsection
Interface IPhone
\end_layout

\begin_layout Subsubsection
Pourquoi une interface mobile ?
\end_layout

\begin_layout Subsubsection
Pourquoi l'IPhone
\end_layout

\begin_layout Subsubsection
Réalisation de lʼinterface dédiée
\end_layout

\begin_layout Subsubsection
Différences de lʼinterface Iphone
\end_layout

\begin_layout Subsection
Pistes d'amélioration
\end_layout

\begin_layout Subsubsection
AJAX
\end_layout

\begin_layout Subsubsection
Compatibilité des appareils mobiles
\end_layout

\begin_layout Section
Interface tactile
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename site-logo.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Société sensitive Object
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nous pensions au début du projet utiliser un produit de la société Sensitive
 Object, qui vend des boitiers prets à l'emploi utilisant cette technologie,
 mais la société était en phase de développement d'un nouveau produit, et
 a refusé de nous vendre l'ancien.
 Nous avons donc provisoirement abandonné cette idée, mais plus tard nous
 avons rencontré un scientifique, Stephan Catheline, qui avait travaillé
 au développement de cette technologie, et nous a assuré qu'il était tout
 à fait possible de la mettre en place nous mêmes en se basant sur l'article
 scientifique joint à ce rapport.
 Nous nous sommes donc mis au travail, et l'idée a été réintégrée au projet.
\end_layout

\begin_layout Subsection
Principe physique
\end_layout

\begin_layout Standard
La localisation du point de contact avec la surface se fait à partir du
 son que produit ce contact.
 Après avoir enregistré le son produit par un contact sur chacun des points
 à reconnaître, on compare un nouveau son avec chacun des sons enregistrés,
 et celui auquel il correspond le plus correspond au point touché.
 Cette technologie est basée sur le retournement des ondes sonores.
\end_layout

\begin_layout Subsubsection
Capture des données
\end_layout

\begin_layout Standard
Les ondes sonores se comportent comme des paquets de particules, et si les
 bords de la surface observée sont suffisamment chaotiques, toutes les 
\begin_inset Quotes eld
\end_inset

particules
\begin_inset Quotes erd
\end_inset

 de l'onde seront passées dans une zone donnée au bout d'un temps suffisamment
 long (appelé temps de Heisenberg), éventuellement après un grand nombre
 de réflexions sur les bords.
 Si on place un capteur dans cette zone, on va recevoir des informations
 venant de tous côtés du point source, et on a virtuellement entouré ce
 point de capteurs.
 Le décalage entre le premier pic, correspondant à l'onde reçue par le trajet
 direct, et les pics suivants, correspondant aux ondes réfléchies, ainsi
 que le nombre de paquets reçus par réflexion sont une signature unique
 du point qui a été tapé sur la surface, et permettent de le distinguer.
\end_layout

\begin_layout Standard
Si le milieu dans lequel on étudie les sons est trop dissipatif, il se peut
 que des paquets d'onde soient complètement absorbés avant d'avoir atteint
 le capteur, et on perd alors des capteurs virtuels sur un coté de la surface,
 ce qui peut affecter le contraste de façon plus ou moins gênante.
 Pour corriger cela, on peut ajouter des capteurs (réels) à d'autres emplacement
s, pour essayer d'intercepter les paquets dans une autre zone avant qu'ils
 ne disparaissent.
 C'est pourquoi nous utilisons deux micros plutôt qu'un dans le projet.
\end_layout

\begin_layout Subsubsection
Calcul de la corrélation
\end_layout

\begin_layout Standard
La corrélation d'un point avec un autre est un nombre indiquant combien
 les deux points sont similaires.
 Ainsi, la corrélation sera maximale entre deux points identiques, et nous
 l'esperons, plus faible ailleurs.
\end_layout

\begin_layout Standard
Considérons une boite noire dont la réponse impulsionnelle est 
\begin_inset Formula $h(t)$
\end_inset

, sa sortie pour une entrée 
\begin_inset Formula $e(t)$
\end_inset

 est 
\begin_inset Formula $h(t)\otimes e(t)$
\end_inset

 (convolution temporelle).
 Si on admet qu'un coup sur la surface tactile est assimilable à un dirac,
 alors on peut définir la réponse impulsionnelle 
\begin_inset Formula $h_{A}(t)$
\end_inset

 de la surface entre le point A et le capteur, qui sera le signal reçu par
 le capteur.
 Or un résultat de la théorie du signal nous dit que pour des entrées normalisée
s, le maximum en sortie d'un filtre de réponse impulsionnelle 
\begin_inset Formula $h(t)$
\end_inset

 est obtenu pour une entrée 
\begin_inset Formula $h(-t)$
\end_inset

.
 Ce maximum correspond au moment où les deux signaux sont en phase et se
 recouvrent parfaitement.
\end_layout

\begin_layout Standard
Donc lorsque l'on reçoit un nouveau son (
\begin_inset Formula $s(t)$
\end_inset

), si on le retourne temporellement (
\begin_inset Formula $s(-t)$
\end_inset

) et qu'on le convolue à tous les signaux connus (
\begin_inset Formula $s(-t)\otimes h_{i}(t)$
\end_inset

), le signal obtenu présentera un pic pour chaque bouton, vu que les signaux
 sont sensilement les mêmes, mais l'amplitude de ce pic sera maximale pour
 le point correspondant à ce son.
 L'amplitude du pic principal de la convolution calculée est la corrélation
 de l'origine du son avec le point 
\begin_inset Formula $i$
\end_inset

.
 Avec cette méthode, on est donc capable de déterminer quel point enregistré
 est le plus proche du point tapé.
 Pour ne pas réagir à des bruits parasites, on peut imposer une corrélation
 minimum pour prendre en compte le résultat.
\end_layout

\begin_layout Paragraph
Explication physique :
\end_layout

\begin_layout Standard
Convoluer le signal retourné temporellement par 
\begin_inset Formula $h_{i}(t)$
\end_inset

, qui est la réponse impulsionnelle de la table, équivaut à renvoyer virtuelleme
nt à travers la table l'onde vers sa source : on fait défiler le temps à
 l'envers, et on observe le signal que l'on a émit avec le coup au point
 
\begin_inset Formula $i$
\end_inset

.
 Le pic principal sera d'autant plus grand que l'on est virtuellement près
 de la source, et on aura évidement un maximum sur la source elle même.
\end_layout

\begin_layout Standard
La précision maximale de cette technique est imposée par la limite de la
 diffraction à 
\begin_inset Formula $\frac{\lambda}{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
Mise en application
\end_layout

\begin_layout Subsubsection
Capture du son
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename murata.jpg
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:murata"

\end_inset

Capteur piézoélectrique
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour enregistrer le son, on utilise des capteurs piézoélectriques (MuRata
 PKS1, voir figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:murata"

\end_inset

), ce qui permet d'écouter uniquement les vibrations de la table sur laquelle
 ils sont plaqués, et pas les bruits extérieurs (un capteur piézoélectrique
 émet un courant proportionel à la déformation qui lui est appliquée).
 En réalité, on reçoit quand même les bruits extérieurs, mais avec une amplitude
 faible par rapport aux bruits propagés dans la table.
 Pour vraiment isoler les micros de l'environement, nous utilisons de la
 pâte à modeler, ce qui permet en même temps de les fixer sur la table.
\end_layout

\begin_layout Standard
Pour écouter l'entrée son, nous nous sommes basés sur le code d'exemple
 fourni par Sun pour les application audio an Java
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Code source disponible à l'adresse : http://java.sun.com/products/java-media/sound
/samples/JavaSoundDemo/
\end_layout

\end_inset

.
 Le code Java utilisé pour la capture audio est présenté dans l'extrait
 de code 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:son"

\end_inset

, sans tenir compte des exceptions et des tests de compatibilité.
 La ligne 1 définit les paramètres de capture.
 Pour le projet nous avons utilisé du son échantillonné à 44,1 kHz et représenté
 sur 16 bits, ce qui est la meilleure qualité que l'on peut obtenir sur
 les cartes son standards.
 Nous avons besoin de cette qualité pour bien différencier les signaux venant
 des points de la surface, car les écarts entre les sons réverbérés sont
 minces (d'autant plus que le son se propage plus rapidement dans les solides).
 À la ligne 2, on récupère l'entrée micro de l'ordinateur, les lignes 3
 et 4 ouvrent la ligne en écoute, et à la ligne 5, on récupère dans un tableau
 d'octets (bytes) les données brutes venant de la carte son.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:son"

\end_inset

Capture du son
\end_layout

\end_inset


\end_layout

\begin_layout LyX-Code

\size footnotesize
AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, sampleRate,
 sampleSizeInBits,
\end_layout

\begin_layout LyX-Code

\size footnotesize
channels, (sampleSizeInBits / 8) * channels, sampleRate, true);
\end_layout

\begin_layout LyX-Code

\size footnotesize
line = (TargetDataLine) AudioSystem.getLine(new DataLine.Info(TargetDataLine.class,
 format));
\end_layout

\begin_layout LyX-Code

\size footnotesize
line.open(format, line.getBufferSize());
\end_layout

\begin_layout LyX-Code

\size footnotesize
line.start();
\end_layout

\begin_layout LyX-Code

\size footnotesize
line.read(data, 0, bufferLengthInBytes);
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Après avoir reçu les données de la carte son avec 
\family typewriter
line.read
\family default
, il reste quelques traitements à appliquer sur l'échantillon : Sachant
 que les données sont récupérées octet par octet alors que l'amplitude est
 échantillonnée sur 16 bits, il faut concaténer les octets reçus deux à
 deux (et obtenir ainsi des données sur 16 bits i.e.
 2 octets) ce qui est illustré par la figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:schema_concatene"

\end_inset

.
 Par ailleurs, sachant que nous récupérons les données de 2 capteurs en
 
\begin_inset Quotes eld
\end_inset

stéréo
\begin_inset Quotes erd
\end_inset

 sur la même entrée, les données alternent entre l'un et l'autre, et il
 faut, après avoir appliqué le premier traitement, les dissocier pour les
 placer dans deux tableaux différents.
 Dans le cas de données 
\begin_inset Quotes eld
\end_inset

mono
\begin_inset Quotes erd
\end_inset

 (1 seul canal), aucun traitement n'est nécessaire.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset External
	template RasterImage
	filename schema_concatene.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:schema_concatene"

\end_inset

Concaténation des données
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pour détecter le signal qui nous intéresse (un choc), nous aurions pu utiliser
 un algorithme pour repérer une forte variation du signal, mais il est plus
 simple et plus rapide de simplement se fixer un seuil d'amplitude en deçà
 duquel les sons ne sont pas pris en compte.
 Pour déterminer ce seuil, nous avons capturé le son pendant 1 seconde avec
 du bruit ambiant pour se fixer une limite inférieure (le bruit ambiant
 ne doit pas être pris en compte), puis nous avons capturé le bruit d'un
 choc, ce qui nous donne une limite supérieure pour le seuil.
 Pour résumer, on fixe le seuil de détection tel que : 
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\textrm{bruit ambiant}<\textrm{seuil}<\textrm{amplitude maximale d'un coup}\]

\end_inset


\end_layout

\begin_layout Subsubsection
Calcul de corrélation par FFT
\end_layout

\begin_layout Standard
Après avoir capturé le son d'un choc sur la surface, on va chercher à calculer
 sa corrélation avec les sons connus (qui est une opération de convolution
 temporelle).
 Un calcul direct de convolution temporelle est effectué par un ordinateur
 en 
\begin_inset Formula $O(n^{2})$
\end_inset

, mais nous pouvons améliorer cette complexité en passant par la représentation
 fréquentielle des signaux, obtenue par tranfsormée de Fourier : en effet,
 une convolution temporelle correspond à une multiplication fréquentielle,
 et le calcul d'une transformée de Fourier rapide (FFT) est opéré en 
\begin_inset Formula $O(n\lg(n))$
\end_inset

 quand 
\begin_inset Formula $n$
\end_inset

 est une puissance de 2 (ce qui permet de procéder par dichotomie en séparant
 les échantillons pairs et impairs), et la multiplication est effectuée
 composante par composante, donc en 
\begin_inset Formula $O(n)$
\end_inset

, puis la transformée de Fourier inverse est identique à la FFT, et la recherche
 du maximum est en 
\begin_inset Formula $O(n)$
\end_inset

.
 La complexité de l'opération est alors dominée par la FFT, en 
\begin_inset Formula $O(n\lg(n))$
\end_inset

.
\end_layout

\begin_layout Standard
On vient de voir que la FFT est plus rapide si n est une puissance de 2,
 mais notre signal capturé n'a pas forcément une longueur qui est une puissance
 de 2.
 Pour corriger cela, on va effectuer un zero padding sur le signal, c'est
 à dire rajouter une série de zéros à la fin du signal jusqu'à atteindre
 la longueur voulue.
 Par ailleurs, on ne cherche à comparer que l'aspect du signal, sans se
 préoccuper de sa puissance, on normalise donc la transformée de Fourier
 du signal, ce qui nous permet de plus d'avoir une corrélation en pourcentage
 (1 correspondant à 100%).
 
\end_layout

\begin_layout Standard
l'ordre des opérations est donc le suivant :
\end_layout

\begin_layout Standard
\begin_inset Formula \[
\textrm{zero padding}\longrightarrow\textrm{FFT}\longrightarrow\textrm{normalisation}\longrightarrow\textrm{multiplication}\longrightarrow\textrm{FFT}^{-1}\longrightarrow\textrm{recherche du maximum (pic)}\]

\end_inset


\end_layout

\begin_layout Standard
et les 3 dernières opérations sont répétées pour chaque son connu.
 La recherche du maximum de corrélation peut être effectuée à la volée.
\end_layout

\begin_layout Paragraph
Remarque : 
\end_layout

\begin_layout Standard
Avec certains micros et/ou cartes son, le signal subit un offset (le silence
 ne correspond pas à la valeur zero), et il a donc une composante continue,
 qui va se traduire par un pic autour de 0 Hz sur sa transformée de Fourier.
 Or cette composante ne nous interesse pas, ce sont les variations du signal
 que nous comparons.
 Pour ne pas prendre en compte cette composante continue, on peut soit commencer
 par soustraire à chaque échantillon la moyenne temporelle du signal, soit
 ne prendre en compte les échantillons qu'à partir d'une certaine fréquence
 (100 Hz par exemple).
\end_layout

\begin_layout Subsubsection
Problèmes rencontrés
\end_layout

\begin_layout Standard
J'ai commencé à développer le projet avec une idée fausse sur la convolution
 : je pensais calculer la corrélation en sommant le produit des deux FFT
 (
\begin_inset Formula $\sum_{i}fft_{1}(i)*fft_{2}(i)$
\end_inset

), alors qu'il faut non pas sommer, mais effectuer une FFT inverse puis
 rechercher le maximum pour avoir la corrélation.
 Car la convolution de 2 signaux n'est pas un scalaire mais bien un signal
 temporel.
 Mon calcul de corrélation était donc biaisé par les lobes secondaires qui
 apparaissent normalement sur le signal convolué, et dont la puissance peut
 être importante.
 Malgré tout, cette méthode fonctionnait, bien qu'avec un contraste (différence
 entre la corrélation au point source et celle sur les autres points) plus
 faible sur les résultats.
 Nous l'avons laissé en place pendant tout la durée du projet, car je me
 suis aperçu de mon erreur vers la fin de la période de développement, et
 nous n'avons pas voulu modifier un code fonctionnel et prendre le risque
 de casser des choses à quelques jours de la présentation.
 Cependant, je compte implémenter ceci à titre personnel après la fin du
 projet.
\end_layout

\begin_layout Standard
Nos autres problèmes sont venus du découpage et de la concaténation des
 données suivant le mode de capture utilisé (16 bits, stéréo...), car ils étaient
 mal documentés dans l'application de démonstration de Sun, et nous avons
 mis quelque temps pour nous comprendre tout seuls comment étaient organisées
 les données venant de la carte son.
 Nous avons utilisé Scilab pour pouvoir afficher et manipuler facilement
 les données.
 En affichant les données sur la sortie standard, puis en la redirigeant
 dans un fichier, ou peut facilement les importer dans un vecteur scilab
 à l'aide de la fonction fscanfMat qui prend en paramètre un nom de fichier.
\end_layout

\begin_layout Subsubsection
Pistes d'amélioration
\end_layout

\begin_layout Paragraph
temps d'exécution
\end_layout

\begin_layout Standard
La principale piste à suivre pour améliorer le temps d'éxecution du programme
 serait de réduire le temps de capture au temps de Heisenberg (durée pendant
 laquelle tous les paquets d'ondes passent par un micro), mais je ne sais
 vraiment pas comment l'évaluer pour une surface donnée.
 On pourrait essayer de s'en rapprocher en procedant par réductions successives
 du temps de capture en verifiant que le contraste reste correct.
 En dehors du temps de capture, l'algorithme est peu gourmand en ressources,
 mais on peut l'améliorer tout dabord en utilisant un language plus proche
 de la machine, comme le C, et en travaillant sur l'algorithme de la FFT
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
le site suivant décrit quelques pistes pour obtenir un algorithme de calcul
 de FFT plus efficace : http://cnx.org/content/m12021/latest/
\end_layout

\end_inset

 (ou en utilisant les implémentations optimisées disponnibles en C, comme
 FFTW
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.fftw.org/
\end_layout

\end_inset

).
\end_layout

\begin_layout Paragraph
précision
\end_layout

\begin_layout Standard
Pour augmenter la précision de détermination des zones tapées, on pourrait
 commencer par réduire la bande passante d'analyse des signaux, pour éviter
 de prendre en compte du bruit à des fréquences plus élevées.
 Il faudrait pour ça effectuer une série de tests en mesurant la fréquence
 des signaux reçus, et en observant les résultats tout en réduisant la plage
 de fréquences de l'étude.
\end_layout

\begin_layout Standard
On pourrait aussi utiliser un algorithme d'apprentissage, qui permettrait
 de différentier les boutons non pas seulement à partir de leur corrélation,
 mais aussi à partir des corrélations des autres boutons.
 Ainsi, on pourrait différentier deux boutons très proches si leur corrélation
 avec un troisième bouton varie de façon significative.
 Il est aussi possible que cette piste de mène à rien, sachant que nous
 n'avons effectué aucun test sur ce point.
\end_layout

\begin_layout Subsection
Intégration au projet
\end_layout

\begin_layout Standard
Le dispositif présenté ci dessus permet de rendre n'importe quelle surface
 tactile avec quelques micros et après avoir calibré les boutons sur cette
 surface.
 Son principal avantage est qu'en plus d'être bon marché, le coût de cette
 technologie ne dépends pas de la taille de la surface à rendre tactile.
 De plus, Il s'agit d'une installation rapide à mettre en place, facilement
 adaptable à de nombreuses configurations : un bouton peut être rajouté
 ou supprimé à n'importe quel moment, et adaptée à un environnement hostile
 : si on place les micros sous une table par exemple, ou peut renverser
 un verre dessus sans endommager le système ; elle est donc particulièrement
 bien adaptée à une solution de domotique.
 
\end_layout

\begin_layout Standard
Nous avons choisi dans notre projet de l'utiliser pour permettre un changement
 de profil dans une pièce, ou dans la maison.
 Cela équivaut à utiliser des interrupteurs intelligents, car contrôlant
 plusieurs dispositifs à la fois, modulables, et avec une occupation de
 l'espace nulle, car les surfaces restent utilisables pour d'autres usages.
 Dans une application commerciale, on peut imaginer utiliser des micros
 sans fil, permettant par exemple au cuisinier de contrôler sa gazinière
 et son four depuis la surface de sa chaise sans quitter ses convives.
\end_layout

\begin_layout Section
Communication
\end_layout

\begin_layout Subsection
Communication avec les IHM
\end_layout

\begin_layout Subsubsection
HashMap partagée
\end_layout

\begin_layout Standard
Les informations concernant la maison sont stockées dans des HashMap partagées
 entre les différentes parties du projet (interface web, interface tactile
 et communication).
 C'est une structure de données permettant d'associer une clé à un objet
 java.
 Dans ce projet par exemple, une HashMap de salles associe le nom des salles
 et les objets Salle correspondant.
 On peut alors, grace à cette HashMap, avoir accès à toutes les informations
 dépendant des salles (type et valeur des capteurs, type et valeur des prises,
 etc...).
 Lorsqu'une nouvelle information est connue, qu'elle vienne de l'utilisateur
 par l'intermédiaire de l'interface web ou bien par la réception de données
 provenant d'un module de capteurs, cette HashMap est mise à jour.
 On travaille donc en permanence avec des données à jour.
\end_layout

\begin_layout Standard
L'interface web utilise la HashMap pour afficher les valeurs de température
 et luminosité actuelles de chaque pièce.
 Elle propose aussi un état à jour de la configuration de la maison (le
 nombre de multiprises, le nombre de modules de capteurs, leur situation,
 la configuration des multiprises, etc...).
\end_layout

\begin_layout Subsubsection
Interface tactile
\end_layout

\begin_layout Standard
Quand on crée un profil via l'interface web, l'utilisateur a la possibilité
 d'y associer une zone de l'inteface tactile.
 Lorsque l'interface tactile reconnait un bouton prédéfini, celle-ci envoie
 à une classe Interfacage un évènement, qui déclenche un changement de profil
 vers le profil associé au bouton tapé.
 
\end_layout

\begin_layout Standard
L'écoute de l'interface tactile est dans la méthode run() d'un Thread.
 Les Threads sont des morceaux de programme pouvant etre exécutés en parallèle.
 Ceci permet que les boutons associés à un changement de profil soient détectés
 bien que la communication avec la multiprise (envoi et réception de messages)
 fonctionne.
\end_layout

\begin_layout Subsection
Communication avec la multiprise
\end_layout

\begin_layout Subsubsection
La connexion
\end_layout

\begin_layout Standard
La multiprise communique avec le serveur par l'intermédiaire d'un réseau
 de type ethernet.
 Ce réseau utilise le CPL (Courants Porteurs en Ligne) ce qui évite de faire
 trainer des fils supplémentaires.
 La multiprise possède un module XPORT de Lantronix.
 C'est un adaptateur série<->ethernet.
 Ce module fonctionne comme une interface réseau classique: elle est identifiée
 par une adresse MAC dont le début est spécifique au constructeur et toujours
 de la forme 
\begin_inset Quotes eld
\end_inset

00:20:4A
\begin_inset Quotes erd
\end_inset

 et une adresse IP.
\end_layout

\begin_layout Standard
Un logiciel fourni par Lantronix est nécessaire pour se connecter une première
 fois au module XPORT en indiquant l'adresse MAC, quand il est dans sa configura
tion 
\begin_inset Quotes eld
\end_inset

sortie d'usine
\begin_inset Quotes erd
\end_inset

.
 Sans celui-ci il n'est pas possible d'y accéder, son adresse IP étant fixé
 par défaut à 0.0.0.0.
 Ce point a posé un problème car l'adresse MAC, normalement écrite sur le
 module lui-meme était effacée.
 Après une perte de temps non négligeable, l'adresse MAC a pu etre récupérée
 par la liaison série.
\end_layout

\begin_layout Standard
Lorsqu'une multiprise est créée, par exemple lorsque l'on charge le fichier
 de configuration de la maison en mémoire, un Thread Communication est instancié
 avec en paramètre l'adresse IP correspondant à la multiprise traitée.
 On crée la connexion à l'aide de l'instruction:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
new Socket(adresse IP, port)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Une fois la connexion créée, une boucle va dérouler les étapes d'écoute
 et d'envoi des données entre le serveur et le XPORT.
 Cette boucle est exécutée continuellement et parallèlement au reste du
 programme puisqu'elle est contenue dans la méthode run() du Thread Communicatio
n.
 Une queue de type ConcurrentLinkedQueue est utilisée pour stocker les messages
 devant etre envoyés à la multiprise.
\end_layout

\begin_layout Enumerate
Vérification de la taille de la queue de messages à envoyer
\begin_inset Newline newline
\end_inset

Si elle n'est pas nulle, on envoie le message qui est en haut de la queue
\end_layout

\begin_layout Enumerate
On attend de recevoir un message ou que le temps d'écoute maximum fixé soit
 dépassé
\end_layout

\begin_layout Enumerate
On regarde si le dernier message reçu est un accusé de réception
\begin_inset Newline newline
\end_inset

Si c'est le cas, on supprime le message qui est en haut de la queue
\begin_inset Newline newline
\end_inset

Sinon si le temps d'écoute maximum est dépassé, on essaie de renvoyer le
 message qui est en haut de la queue
\end_layout

\begin_layout Standard
Avec ce système, si jamais un message n'est pas reçu par la multiprise,
 il est renvoyé et aucune information n'est perdue.
\end_layout

\begin_layout Subsubsection
Le protocole
\end_layout

\begin_layout Standard
Un protocole de communication des données a été défini en commun avec l'équipe
 de la partie électronique.
 Les messages envoyés et reçus sont formatés de façon à etre reconnus par
 les programmes communiquant (dans le serveur et dans le microcontroleur
 de la multiprise).
\end_layout

\begin_layout Standard
Voici les différents types de messages définis.
 Tout message n'étant pas formaté de cette façon n'est pas traité:
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

reçu
\begin_inset Quotes erd
\end_inset

 correspond au sens multiprise->serveur
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset

envoyé
\begin_inset Quotes erd
\end_inset

 correspond au sens serveur->multiprise
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset

0011xxxxx
\begin_inset Quotes erd
\end_inset

 représente l'adresse d'un module de capteurs où 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 est une valeur numérique
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Itemize
/0011xxxxx:::::NOUVEAU::::
\backslash
 est reçu lorsqu'un nouveau module de capteurs est installé dans une pièce
\end_layout

\begin_layout Itemize
/0011xxxxx
\backslash
 est envoyé à la multiprise qui veut recevoir les données du module 0011xxxxx
\end_layout

\begin_layout Itemize
/ACK:0011xxxxx
\backslash
 est reçu pour accuser réception de l'ajout d'un nouveau module de capteurs
\end_layout

\begin_layout Itemize
/0011xxxxx:d0:d1:d2:d3
\backslash
 est reçu toutes les deux secondes et contient les données des quatre capteurs
 du module 0011xxxxx
\end_layout

\begin_layout Itemize
/REQ:prise:valeur
\backslash
 est envoyé pour changer la valeur d'une prise
\end_layout

\begin_layout Itemize
/ACK:prise:valeur
\backslash
 est reçu pour accuser réception d'une commande
\end_layout

\begin_layout Subsection
Reconnaissance de matériel
\end_layout

\begin_layout Standard
Une fonctionnalité importante du projet est la possibilité d'ajouter de
 nouveaux appareils sans nécessiter de modification dans l'installation.
 Ceci est possible par son architecture modulaire.
\end_layout

\begin_layout Standard
Des capteurs peuvent etre ajoutés sur les modules de capteurs tant que de
 la place est disponible.
 Si ce n'est pas le cas, il faut ajouter un nouveau module de capteurs.
 Lorsqu'un module est ajouté et mis sous tension, celui-ci va envoyer un
 message dans les airs.
 Les multiprises avoisinantes vont le recevoir et le transmettre au serveur.
 Le premier message reçu va permettre d'associer le nouveau module à la
 multiprise et il va etre ajouté dans l'interface web pour que l'utilisateur
 puisse paramétrer dans quelle salle il se trouve.
\end_layout

\begin_layout Standard
Il est aussi possible d'ajouter une multiprise.
 Lorsque celle-ci est branchée sur le réseau, elle envoie sur tout le réseau
 un message DHCPDISCOVER contenant l'adresse MAC de la multiprise.
 Un serveur DHCP tourne sur notre serveur.
 C'est un logiciel qui permet d'attribuer une adresse IP à une interface
 détectée sur le réseau.
 Le serveur DHCP va recevoir ce message DHCPDISCOVER et l'écrire dans le
 fichier syslog du système.
 Ce fichier log est lu par notre programme, qui vérifie s'il s'agit bien
 d'une adresse MAC d'un module XPORT.
 Si oui il va modifier le fichier de configuration du serveur DHCP afin
 d'y ajouter la possibilité d'attribuer une adresse IP à la nouvelle multiprise.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 représente le numéro du XPORT ajouté
\begin_inset Newline newline
\end_inset


\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 représente un chiffre hexadécimal
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
host XPORTn {
\begin_inset Newline newline
\end_inset

 hardware ethernet xx:xx:xx:xx:xx:xx ; fixed-address 192.168.0.n; 
\begin_inset Newline newline
\end_inset

}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
De cette manière, si un ordinateur ou toute interface réseau n'étant pas
 un XPORT est reliée au réseau, le serveur DHCP du serveur domotique n'en
 tiendra pas compte et ne lui attribuera pas d'adresse IP.
\end_layout

\begin_layout Standard
Comme pour les modules de capteurs, on ajoute ensuite la nouvelle multiprise
 au fichier de configuration de la maison et l'utilisateur pourra paramétrer
 cette multiprise dans l'interface web.
\end_layout

\begin_layout Section
Ce que nous n'avons pas eu le temps de développer
\end_layout

\begin_layout Standard
Si nous avions eu plus de temps, nous aurions pu integrer un système de
 calendrier à la gestion de la maison (par exemple google calendar), qui
 aurait permis des changements automatiques de profils, alors qu'actuellement,
 ils doivent être effectués à la main.
\end_layout

\begin_layout Standard
Nous aurions aussi aimé utiliser des capteurs de présence à l'entrée des
 salle, toujours pour automatiser les changements de profil, ce qui aurait
 accru le confort pour l'utilisateur, ainsi que l'acpect écologique du projet
 : en sachant qu'il n'y a personne dans la pièce, on s'empresse d'éteindre
 de la lumière, voire de baisser la température d'un degré, et si quelqu'un
 arrive, la pièce se configure à ses attentes sans attendre d'ordres.
\end_layout

\begin_layout Standard
Dans notre vision finale du projet, nous aurions utilisé des micros sans
 fil pour placer des interfaces tactiles vraiment partout sans encombrement.
 Ces micros sans fils auraint pu communiquer avec les multiprises, à la
 manière des modules de capteurs, qui auraient relayé l'information vers
 l'ordinateur pour être traitée.
\end_layout

\begin_layout Standard
Toujours dans une optique écologiste, nous aurions pu integrer une facette
 de sensibilisation de l'utilisateur, lui proposant de réduire la température
 du chauffage si le programme l'estime trop élevée, de couper la chaudière
 quand l'été arrive, et nous aurions même pu analyser les comportements
 de l'utilisateur et lui proposer de changer ses horaires pour profiter
 plus longtemps de la lumière du soleil par exemple.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
apprentissage de svn
\end_layout

\begin_layout Standard
gantt project
\end_layout

\begin_layout Standard
serveur web java
\end_layout

\begin_layout Standard
application de FFT et resoluton de systèmes linéaires
\end_layout

\begin_layout Standard
travail en gros groupe
\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
includepdf[pages=-]{/home/raphael/Documents/TeX/rapport/APLInteractif.pdf}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
